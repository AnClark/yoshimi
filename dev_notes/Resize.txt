FLTK manges window resizes itself, but not text or some user drawn graphics. Our resize code fills in these elements.

It closely follows the context idea that the rest of Yoshimi uses. The way this operates is as follows.

First of all the 33mS timer used to fetch VU metering data also sets a trigger. This is then recognised by the normal update code in "MiscGui" which passes the request on to "MasterUI", and then clears the trigger. This procedure ensures that there will be at least 33mS between redraws, thus reducing processor loading.

When "MasterUI" first gets the call it passes it on to all the other top level windows in sequence, but *only* if their size has actually changed. It then passes the call unconditionally to the other main areas, PartUI and BankUI, and finally runs through its own objects.

Part and Bank will themselves portion out calls to subsections depending on whether they can be dealt with directly, or have to be passed further down the stack. For an extreme example, the Amplitude Freemode window in Addsynth Voice has to unconditionally receive this call. It's complete route is:

miscGui->Master->Part->PartEdit->AddGlobal->AddVoice->AddEnvelope

If it is visible, and it's size has changed it will then perform the actual text font resizes, then mark iself as 'seen'. Font sizes are calculated from the ratio of the current window size against the default size, and the font itself multiplied by this scale factor. Fonts are defined as integers so will visibly step up and down in size. Other drawn elements will change smoothly.

Usually only one window at a time will be changing, so apart from the tests made on the way, there is little extra work.

Currently no FLTK file chooser resize. We will be replacing it with our own code.

Completed
    Everything except the filer window!

In progress
    nothing

*** UPDATE ***
All functions are now complete.

We no longer use the VU metering timer as a trigger for resizes. Instead it is the top-lever FLTK one use in 'main' for standalone, and idividual LV2 loops. At the same time, this is now used for reading the ring buffer handling all general GUI updates. As well as being more correct, this has efficiency benefits.
